import { Meta, Story, Canvas, Controls } from "@storybook/blocks"
import * as AvatarNameSelectorStories from "./index.stories"

<Meta of={AvatarNameSelectorStories} />

# AvatarNameSelector

The AvatarNameSelector component is an advanced selector that allows users to
select entities with avatars, either in single or multiple mode. It supports
grouping, search, and nested selection.

## Features

- Single or multiple entity selection
- Support for groups and subgroups
- Real-time search with debounce
- Always-open mode or popover type
- Customizable trigger
- Loading states support
- Built-in accessibility

## Basic Usage

```tsx
import { AvatarNameSelector } from "@factorial/ds"

function MyComponent() {
  const [selected, setSelected] = useState([])

  return (
    <AvatarNameSelector
      entities={myEntities}
      selectedAvatarName={selected}
      onSelect={setSelected}
      triggerPlaceholder="Select employees..."
    />
  )
}
```

## Props

<Controls />

## Examples

### Default Multiple Selector

The default mode allows selecting multiple entities.

<Canvas of={AvatarNameSelectorStories.Default} />

### Single Selector

Single selection mode that only allows selecting one entity at a time.

<Canvas of={AvatarNameSelectorStories.SingleSelector} />

### Always Open

Mode that keeps the selector always visible, useful for forms.

<Canvas of={AvatarNameSelectorStories.AlwaysOpen} />

### With Custom Trigger

Example of how to customize the selector trigger.

<Canvas of={AvatarNameSelectorStories.WithCustomTrigger} />

## Types

```typescript
interface AvatarNamedEntity {
  id: number
  name: string
  searchKeys?: string[]
  expanded?: boolean
  subItems?: AvatarNamedSubEntity[]
}

interface AvatarNamedSubEntity {
  subId: number
  subName: string
  subSearchKeys?: string[]
}

interface AvatarNamedGroup {
  label: string
  value: string
  type?: string
}
```

## Best Practices

1. Use `searchKeys` to enhance search with alternative terms
2. Provide clear messages for empty states and errors
3. Consider using `alwaysOpen` for long forms
4. Implement loading state management for better UX
5. Customize the trigger according to usage context
